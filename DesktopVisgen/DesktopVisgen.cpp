// DesktopVisgen.cpp : 
//IntroductonToOOP

#include <iostream>
using namespace std;
#define delimeter "\n----------------------------------------------\n"
class Point//Создавая структуру или класс, мы создаем новый тип данных.
{//Классы и структры еще называют пользовательскими или составныими типами данных.

    double x;
    double y;
public:
    double get_x()const
    {
        return x;
    }
    double get_y()const
    {
        return y;
    }
    void set_x(double x)
    {
        this->x = x;
    }
    void set_y(double y)
    {
        this->y = y;
    }
    //    Constructors:
    
    /*Point()
    {
        x = y = 0;
        cout << "DefConstructor:\t" << this << endl;
    }*/
   /* Point(double x)
    {
        this->x = x;
        this->y = 0;
        cout << "1ArgConstructor:\t" << this << endl;
    }*/
    Point(double x=0, double y=0)
    {

        this->x = x;
        this->y = y;
        cout << "2ArgConstructor:\t" << this << endl;
    }
    Point(const Point& other)
    {
        this->x = other.x;
        this->y = other.y;
        cout << "CopyConstructor:\t" << this << endl;
    }
    ~Point()
    {
        cout << "\nDestructor:\t" << this << endl;
    }
    
    //      Operators:

    Point& operator=(const Point& other)
    {
        this->x = other.x;
        this->y = other.y;
        cout << "CopyAssigment:\t" << this << endl;

        return *this;
    }

    Point& operator++()
    {
        x++;
        y++;
        return *this;
    }
    Point operator++(int)
    {
        Point old = *this;
        x++;
        y++;
        return old;
    }

    Point& operator()(double x, double y)
    {
        set_x(x);
        set_y(y);
        return *this;
    }



    //    Method
    double distance(const Point& other)
    {

        double x_distence = this->x - other.x;
        double y_distance = this->y - other.y;
        double distance = sqrt(x_distence * x_distence + y_distance * y_distance);
        return distance;
    }
    void print()const
    {
        cout << "X = " << x << "\tY = " << y << endl;
    }

};
double distanse(const Point& A, const Point& B)
{
    double x_distance = A.get_x() - B.get_x();
    double y_distance = A.get_y() - B.get_y();
    double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
    return distance;
}

Point operator+(const Point& left, const Point& right)
{
    Point res;
    res.set_x(left.get_x() + right.get_x());
    res.set_y(left.get_y() + right.get_y());
    return res;
}
// Comparison operators:
bool operator==(const Point& left, const Point& right)
{
    return left.get_x() == right.get_x() && left.get_y() == right.get_y();
}

bool operator!=(const Point& left, const Point& right)
{
    return!(left == right);
}
std::ostream& operator<<(std::ostream& os, const Point& obj)
{
    return os << "X = " << obj.get_x() << "\tY = " << obj.get_y();
}

std::istream& operator >>(std::istream& is,  Point& obj)
{
    double x, y;
    is >> x >> y;
    obj(x, y);
    return is;

}

//#define struct_point;
//#define distance_check
//#define CONSTRUCTR
//#define ASSIGMENT_CHECK_1
//#define ASSIGMENT_CHECK_2
int main()
{
    setlocale(LC_ALL, "RUS");

    //cout << "Hello OOP" << endl;
    #ifdef struct_point



    int a;//Объявление ппременной а типа int
    Point A;// Объявление переменной А типа Point
    //Объявление объекта А структуры Point
    //Создание экземпляра А структуры Point


    //A.x = 2;
    //A.y = 3;
    #endif // struct_point
    #ifdef distance_check

  

    Point A;
    Point B;
    B.set_x(7);
    B.set_y(8);
    A.set_x(2);
    A.set_y(3);
    cout << A.get_x() << "\t" << A.get_y() << endl;
    cout << delimeter <<endl;
    cout << "Растояние от точки А до точки B: " << A.distance(B) << endl;
    cout << delimeter << endl;
    cout << "Растояние от точки B до точки A: " << B.distance(A) << endl;
    cout << delimeter << endl;
    cout << "Растояние между точками А и В:   " << distanse(A, B) << endl;
    cout << delimeter << endl;
    cout << "Растояние между точками А и В:   " << distanse(B, A) << endl;
    cout << delimeter << endl;
    #endif//
    #ifdef CONSTRUCTR



    Point A;
   // cout << A.get_x() << "\t" << A.get_y() << endl;
    A.print();

    Point B(2, 3);
    B.print();

    Point C = 4;//Single-Argument constructor
    C.print();

    Point D = C;
    D.print();
    #endif // CONSTRUCTR
    #ifdef ASSIGMENT_CHECK_1



    Point A(2, 3);
    A.print();
    Point B = A;    //СopyConstructor
    B.print();
    Point C;
    C = B;      //ASssigment operator
    C.print();
    #endif // ASSIGMENT_CHECK_1
    #ifdef ASSIGMENT_CHECK_2



    int a, b, c;
    a = b = c =0;

    Point A, B, C;
    cout << delimeter << endl;
    A = B = C = Point(2, 3);
    cout << delimeter << endl;
    //Point(2, 3); - явный вызов конструктора, и этот конструктор создает временный безымянный объект, 
    //Временные беземянный объеект существует в пределах одного вырожения

    #endif // ASSIGMENT_CHECK_2

   // int a = 2;
   // int b = 3;
   // int c = a + b;

   // Point A(2, 3);
   // Point B(4, 5);
   ///* Point C = A + B;
   // C.print();
   // cout << delimeter << endl;
   // C++;
   // cout << delimeter << endl;
   // C.print();*/

   // cout << (A == B) << endl;
   // cout << (A != B) << endl;

    Point A(2, 3);
    A.print();
    /*A.set_x(12);
    A.set_y(13);*/
    A(4, 7);
    //A.print();
    cout << A <<endl;

    cout << "Введите координаты точки: ";
    cin >> A;//cin это объект класса istream)
    cout << A << endl;

    //Объектнор орентированное программирование на языке С++
    //ООП Оbject_Oriented Programming- Это подход при котором программа строиться из объектов
    //Объекты могут взаимодействовать между собой
    //к Ключевым понятиям ООП являться Объект
    //Это некотороая сущьность, котороая существует в пространстве и времени.
    //Объекты могут существовать в объективной, субъективной, или в виртуальной реальности.
    //ооп позваляет спроекцировать объекты объективной и субъективной реальности в виртуальную реальность.
    //
    //у каждого объекта есть свои характеристики состояние и поведение. 
    // Объеты принято класифицировать 
    //множество объектов в одинаковым набором характеристик поведений и состояний называеться классом
    // например класс телефон, человек машина, компьютер и тк,д
    // с точеки зрения ооп, 
    // Класс-это синтаксическая конструкция позваляющая описывать объекты
    // кроме классов объекты так же можно описывать при помощи структур.
    // Классы и Структуры состоят из полей, или из членов(members).
    // Поля классов или структур бывают двух типов.
    // 1. Перемнные члены класса- описывают характеристики и состояния объектов.
    // 2. Методы- определяют поведение объектов и взаимодействие их с другими объектами
    // 
    // МЕТОД- Это функция внутри класса. 
    // МЕТОД может быть вызван только для какого-то объекта.
    // классы и иструкты часто изображают в виде UML-диаграммы
    // Data- переменные челены класса, описывает характеристики и состояние объекта
    // Methods-функции внутри класса, определяют поведение объектов и взаимодействие их с другими объектами
    // 
    //Объекты часто называют экземплярами класса или структры.
    //
    //Класс- Это тип данных!!!
    //Структура это тип данных!!!
    // ------------------------------------------------------
    //для обращение к полям объекта можно использовать 
    // 
    //оператор '.'- Оператор прямого доступа(Point operator)
    //используеться для доступа к полям объекта по имени объекта 
    // 
    //оператор '->' Оператор косвенного доступа(Arrow operator)
    //используеться для доступа к полям объекта по адресу объекта
    // 
    // Единственное отличие между классом и структурой то что в струкутре все поля по умолчанию открыты
    // а в классе все поля по умолчанию закрыты
    //--------------------------------------------------------
    //КОНЦЕПЦИИИ ООП
    // ------------------------------------------------------
    //1. Инкапсуляция (Encapsulation);
    // Модификаторы доуступа:
    // ====================================================
    // Private:--Закрытиые поля, доступны только внутри класса
    // Перемнные члены класса обязательно должны быть приватными,
    // Это защищает Их от случайной перезаписи.
    // =====================================================
    // public:--Открытые поля доступные из любого места программы
    // в Паблик секции обычно размещают Методы
    // =====================================================
    // protected:--Это защищенные поля, доступны внутри нашего класса и его дочерних классов
    // (Этот модификатор доступа используеться только при наследовании)
    // get/set-мектоды обеспечивают доступ из вне к закрытым переменнам в классе
    // 
    // Get-взять,получить-позволяют получить (взять) 
    // значение переменной(Открывают доступ на чтнениек переменным членам класса)
    // Get-методы обязательно должны быть константными.
    // конст-называеться метод который не изменяет объект для которого вызываеться.
    // дя константного объекта могут быть вызванны только константные методы.
    // 
    // Set(устоновить, задать)- позволяет задать значение переменной в классе
    // (открывают доступ к переменным челенам класса на запись).
    // кроме того Set методы обеспечивают фильтрацию данных.
    // 
    // this-> это указатель на объект для которого вызываеться метод.
    // 
    //2. Наследование (iNHERITANCE);
    //3. Полиморфизм(Polymorphism);
    //
    //Инкапсуляция-это сокрытия определенной части класса от внешнего мира
    //Инкапсуляция  реализуеца модификаторами доступа и get/set Методы
    // 
    // ОСОБЫЕ МЕТОДЫ В КЛАССЕ
    // В любом классе обязательно должны быть такие методы как
    // 
    // 1.КОНСТРУКТОР(Constructor)-это метод, который создает объект а именно выделяет память под объект 
    // и инициализирует его поля при создании объекта
    // Конструктор и диструктор всегда называються так же как и класс но перед диструктором всешгда ставиться символ ~
    // Конструктор и диструктор никогда не возвращает никаких значений и при этом  перед ними даже не пишеться void.
    // Конструтор как и любая другая функция может принимать параметры по этому как и любую другую функцию его можно 
    // перегрузить, это означает в классе может быть сколько угодно конструкторов.
    // ------------------------------------------------
    // 2.ДИСТРУКТОР(~Destructor)-это метод который уничтожает объект, по истечении его времени жизни
    // время жизни объекта истекает, когда мы выходим за приделы области видимости в которой объявлен этот объект
    // например при завершении функции в которой объявлен объект, или если счетчик типа фор считать объектом
    // то по завершение всех операция фора в для его счетчике будет вызван диструктор.
    //  
    // Диструктор же никогда не принимает никаких параметров и перегузить его нельзя следовательно в любом классе может 
    // быть только 1 диструктор.
    // объекты могут создавться по разному но все объекты могут удаляться одинкого 
    // в не зависимости от того как они были созданны.
    // 3 ОПЕРАТОР ПРИСВАЕВАНИЯ(Assingmen operator)
    // ===================================================================================
    // Конструкторы бывают, с параметрами, без параметров, по умолчанию, конструктор копирования и конструктор переноса
    // 1. Конструктор по умолчанию- это конструктор который может быть вызван без параметров.
    // это может быть конструктор не принимающих никаких параметров или же конструктор каждый параметр которого имеет 
    // значение по умолчанию.
    // Конструктор по умолчанию выделяет память под объект и инициализирует все его помля значениями ппо умолчанию
    // конструктор по умолчанию всякий раз не явно вызываеться когда мы просто создаем объект и не знаем каким он будет.
    // Конструктор по умолчанию может быть неявным, то есть если в классе нет не одного конструктора то компелятор сам добавит 
    // туда конструктор по умолчанию, потому что без конструктора невозможно создать объект.
    // такой не явный конструктор по умолчанию, просто выделяет память под объект, и инициализирует его поля значениями по умолчанию
    // 
    // если мы хотим определять каким будет объект при его создании то нам нужен конструктор с параметрами.
    // Особое место в параметрозованных конструкторах занимает конструктор с одним параметром.
    // Конструктор с параметром по умолчанию может вызывать во всех ситуациях при создании объекта
    // но иногда лучше перегрузить конструктор чем испоользовать уневерсальный конструктор
    // 
    // 2.Конструктор копирования- Это конструктор который копирует объект а именно создаваемый объект делает точной копией
    // какого-то существуещего объекта. Конструктор копирования всегда принимает константную ссылку на объект нашего класса.
    // он всякий раз неявно вызываеться когда нужно скопировать объект. Нарпример Point D=C- вызываеться Copy constructor
    // Так же как и конструктор по умолчанию конструктор Копирования может быть не явным. То есть если мы его не написали
    // то компилятор сам его добавит. Конструктор копирования особенно важен при использование в классе динамической памяти
    // он должен выполнять Deep copy- глубокое копирование(побитовое копирование, побайтовое копирование)
    // не явное конструктор копирование не может этого сдлелать и делает Shallow copy- Пповерхностное копирование, 
    // Т.е копирование адреса памяти вместо содиржимого памяти. Если возникате необходимость скопировать объект после его создания.
    // а именно существуещий объект сделать точной копией другого существуещего объекта, для этих целей мы не сможем вызвать
    // конструктор копирования, потому что любой конструктор может быть вызван только для создания объекта.
    // Конструктор невозможно вызвать для созданого объекта.
    // Для того что бы скопировать существующий объект, вызываеться ОПЕРАТОР ПРИСВАЕВАНИЯ. CopyAssigment
    // Оператор присваевания делает то же самое что и конструктор копирования но после создания объекта.
    // так же как и конструктор копирования, оператор присваевания принимает константную сслыку на объект. 
    // и выполняет те же действия но уже для существующего объекта. так же как и конструктор копирования оператор присваевания 
    // критически важен если в классе используеться динамическая память. Он так же можент быть неявным. 
    // так же как и конструктор копирования оператор присваевания должен выполнять дип копи
    // мы передвали параметры в функции (по значению, по сылки, по указателю)мы не говрили как функция может возврщать значение
    // Значение из функции так же может возвращаться (по значению, по указателю, по ссылке). 
    // И по возрате значения по значению воозврщаемое значение копируеться на место вызова. А при возврате значения по указтелю либо
    // по сысслке, На место вызова копируеться адрес возвращаемого значения. Если возврщаемое значение являеться объектом,
    // для того что бы его скопировать на место вызова вызываеться конструктор копирования.
    // Для того что бы скопировать адрес объекта конструктор копирования не нужен.
    // При возврате объекта по значению создаеться еще один объект, что приводит к доп затратам ресурсов. 
    // и возвращая объект по адресу можно сэкономить ресурсы, но здесь нужно быть очень осторожным. 
    // Поскольку если мы вернем сслыку или указатель на локальный объект, то он удалиться по завршению функции.
    // И на месте вызова мы увидем мусор.
    // Область видимости может состоять из немсколких вырожений, при этом одно вырожение являеться областью видиммости.
    // RGB-на каждый из этих показателей хранит 1 байт, и альфа канал. получаеться 4 байта.
    // ==========================================================================================
    // Перегрузка операторов- перегрузка операторов нужна для более удобной работы с объектами, что бы над объектами
    //  можно было выполнять такие же действия как над обычными переменнами.
    // 
    //  1)Правила прегрузки оператора Перегрузить можно только существующие операторы.невозможно создавать новые операторы
    //  Например: 
    // + - перегружаеться;
    // ++ - перегружаеться
    // *- перегружаеться
    // **- не перегружаеться
    // 2) Не все существующие операторы можно перегрузить.
    //  Не перегружаеться: 
    //  ?:- conditional ternary
    //  ::-Scope operator(Оператор разрешение видимости)
    //  .- Point operator(оператоор пррямого доуступа)
    //  .* -Poiner to member selectoin
    //  #-Preprocessor directive
    //  ##-Preprocessor concatenation
    // 3) Переопределить поведение оператороа над встроиными типами невозможно.
    // Например: невозможно заставить оператор + выполнять какие то другие действия над типам данных int кроме сложения.
    // 4) Перегруженные операторы сохраняют приоритет.
    // 
    // Перегруженные операторы, это самые обычные функцие, имя которых состоит из ключегого слова оператор(operator)
    //  и знака существующего оператора "=". Эти функции можно описать как в классе так и за классом
    // если оператор перегружен в классе, то он являеться методом, А значит может быть вызван только для какого то объекта
    // Если оператор перегружен за классом, то он являеться самой обычной функцией, А значит может быть вызван сам по себе.
    // 
    // Если унарный опретор перегружен внутри класса, то он никогда не принимает никаких парметров.а единственным его операндым
    // являеться для котрого он вызываеться. и к этому объекту можно обращаться через this. 
    // если унарный прегружен за классом,то он в обязательном порядке принимает 1 и только 1 параметр. свой операнд. 
    // Если бинарный оператор, перегружен внутри класса. то он в обязательном порядке принимает 1 и только 1 параметр, 
    // свой операнд справа. а его операндом слева являеться 
    // объект для котрого он вызываеться. 
    // Если бинарный оператор перегружен за классом. То он в обязательном порядке принимает два параметра. Свои операнды.
    // 
    // При прегрузки операторов, Всегда стоит учитывать что некоторые операторы изменяет свои операнды а некоторые нет.
    // Те операторы которые изменяют свои операнды, удобнее перегружать внутри класса, 
    // что бы иметь прямой доуступ к перемнным челенам класса. те операторы которые не изменяют свои операнды.
    // удобнее перегружать за классом. 
    // ==========================================================================
    // Перегрузка операторов сравнения-Операторы сравнения всегда возвращают значения типа BOOL.
    // Их лучше перегружать за классом, потому что они не изменяют свои операнды.
    // ------------------------------------------------------------------------------
    // Преобразования типов
    // Существуют явные и не явные преобразования типов.
    // Явные преобразования выполняет программист а не явные компелятор.
    // Для того что бы, явно преобразовать значение в другой тип данных, Необходимо желаеммый тип данных написать 
    // в круглых скобках перед значением. иили значение в круглых скобках после желаемого типа данных.
    //  (type)value; C like notation (С подобнобная форма записи)
    //  type(value); Functional notation (Функциональная форма записи)
    //  Не явные преобразования типов выполняет компелятор а именно операторы.
    // Все операторы с++ пытаються привести вырожению к наибольшиму типу даных, для того что бы избежать потери данных
    // и вернуть максимально точный результат. кроме присваении.
    // Операторы присваевыания всегда значение справа приводят к типу слева если типы преобразуються.
    // и не важно произайдет при этом потер данных или нет.
    // /как явные так и не явные преобразования бывают от меньшего к большому как и от большого к меньшему при чем последнее
    // может привести к потери данных. при этом компилятор обычно выдает предупреждение C4244 возможна потеря данных.
    // ======================================================================================================
    // преобразование типов в ООП
    // в ООП существует два направления преобразования типов
    // 1. Преобразование других типов в наш
    //      1)Single-argument constructor конструктор с 1 параметром
    //      2)Assignment operator; оператор присваевания
    // При чем второй без 1 не работает
    // 2. преобразование из нашего типа в другие типы
    // Для преобразования других типов в объекты нашего класса в классе должны быть конструктор с 1 параметром
    // Конструктору с 1 параметром к конструктору с 1 параметром применимо ключевое слово explicit- явный
    // ключевое слово explicit запрещает не явное преобразование типов и остовляет возможность лиж явно преобразовывать типы
    // 
    // Для того что бы объекты нашего класса преобразовывать в другие типы данных в классе должны быть
    // соответвующие операторы преобразования. операторы преобразования (Type-cast operators)
    // самые обычные методы имя которых состоит из ключего слова оператор и спецификатора существующего типа 
    // operator type()const
    // (conversion algorithm;
    // return ...;
    // )
    // Операторы преобразования могут бытьт перегруженны только внутри класса.
    // Операторы преобразования в обязательном порядке возвращают значение хотя перед ними не пишеться тип возвращемого значения..
    // поскольку он являеться частью имени оператора
    // к операторам преобразованиия типов так же принимимо ключевое слово explicit которое так же запрещает не явные преобразования.
    // 
    //


}


